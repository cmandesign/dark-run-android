#!/usr/bin/env node

/**
 * Audio Generation Script
 *
 * Reads localization JSON files and generates speech audio using ElevenLabs API.
 * Also generates the audioAssets.ts registry file with static require() mappings.
 *
 * Usage:
 *   ELEVENLABS_API_KEY=sk_... node scripts/generate-audio.js [locale]
 *
 * Arguments:
 *   locale  - Language locale to generate (default: "en")
 *
 * Environment:
 *   ELEVENLABS_API_KEY - Required. Your ElevenLabs API key.
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

const API_BASE = 'https://api.elevenlabs.io/v1';

// --- Config ---

const locale = process.argv[2] || 'en';
const apiKey = process.env.ELEVENLABS_API_KEY;

if (!apiKey) {
  console.error('Error: ELEVENLABS_API_KEY environment variable is required.');
  console.error('Usage: ELEVENLABS_API_KEY=sk_... node scripts/generate-audio.js [locale]');
  process.exit(1);
}

const projectRoot = path.resolve(__dirname, '..');
const localizationFile = path.join(projectRoot, 'src', 'audio', 'localization', `${locale}.json`);
const outputDir = path.join(projectRoot, 'assets', 'audio', locale);
const assetsRegistryFile = path.join(projectRoot, 'src', 'audio', 'audioAssets.ts');

// --- Helpers ---

function makeRequest(url, options, body) {
  return new Promise((resolve, reject) => {
    const req = https.request(url, options, (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(Buffer.concat(chunks));
        } else {
          const text = Buffer.concat(chunks).toString('utf-8');
          reject(new Error(`HTTP ${res.statusCode}: ${text}`));
        }
      });
    });
    req.on('error', reject);
    if (body) req.write(body);
    req.end();
  });
}

async function generateSpeech(text, voiceId, modelId, voiceSettings) {
  const url = `${API_BASE}/text-to-speech/${voiceId}`;
  const body = JSON.stringify({
    text,
    model_id: modelId,
    voice_settings: {
      stability: voiceSettings.stability,
      similarity_boost: voiceSettings.similarity_boost,
    },
  });

  const options = {
    method: 'POST',
    headers: {
      'xi-api-key': apiKey,
      'Content-Type': 'application/json',
      Accept: 'audio/mpeg',
    },
  };

  return makeRequest(url, options, body);
}

async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function generateAssetsRegistry(locales) {
  const lines = [
    '// AUTO-GENERATED by scripts/generate-audio.js',
    '// Do not edit manually. Run the audio generation workflow to update.',
    '',
    'export const AUDIO_ASSETS: Record<string, any> = {',
  ];

  for (const { locale, keys } of locales) {
    for (const key of keys) {
      lines.push(`  '${key}': require('../../assets/audio/${locale}/${key}.mp3'),`);
    }
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

// --- Main ---

async function main() {
  console.log(`\nAudio Generation Script`);
  console.log(`=======================`);
  console.log(`Locale: ${locale}`);
  console.log(`Localization file: ${localizationFile}`);
  console.log(`Output directory: ${outputDir}\n`);

  // Read localization file
  if (!fs.existsSync(localizationFile)) {
    console.error(`Error: Localization file not found: ${localizationFile}`);
    process.exit(1);
  }

  const localization = JSON.parse(fs.readFileSync(localizationFile, 'utf-8'));
  const { voice, entries } = localization;

  if (!voice || !entries) {
    console.error('Error: Localization file must have "voice" and "entries" fields.');
    process.exit(1);
  }

  const voiceId = voice.voiceId;
  const modelId = voice.modelId || 'eleven_flash_v2_5';
  const voiceSettings = voice.settings || { stability: 0.7, similarity_boost: 0.8 };

  // Ensure output directory exists
  fs.mkdirSync(outputDir, { recursive: true });

  const entryKeys = Object.keys(entries);
  const totalEntries = entryKeys.length;
  let generated = 0;
  let skipped = 0;
  let failed = 0;

  console.log(`Found ${totalEntries} entries to generate.\n`);

  for (const key of entryKeys) {
    const text = entries[key];
    const outputFile = path.join(outputDir, `${key}.mp3`);

    // Skip if file already exists (incremental generation)
    if (fs.existsSync(outputFile)) {
      const stat = fs.statSync(outputFile);
      if (stat.size > 0) {
        console.log(`  [SKIP] ${key} (already exists)`);
        skipped++;
        continue;
      }
    }

    console.log(`  [GEN]  ${key}: "${text}"`);

    try {
      const audioBuffer = await generateSpeech(text, voiceId, modelId, voiceSettings);
      fs.writeFileSync(outputFile, audioBuffer);
      generated++;

      // Rate limit: ElevenLabs free tier allows ~2-3 requests/second
      await sleep(500);
    } catch (err) {
      console.error(`  [FAIL] ${key}: ${err.message}`);
      failed++;
    }
  }

  console.log(`\nGeneration complete:`);
  console.log(`  Generated: ${generated}`);
  console.log(`  Skipped:   ${skipped}`);
  console.log(`  Failed:    ${failed}`);
  console.log(`  Total:     ${totalEntries}\n`);

  // Generate audioAssets.ts registry
  console.log(`Generating asset registry: ${assetsRegistryFile}`);

  // Find all successfully generated keys (existing + newly generated)
  const successfulKeys = entryKeys.filter((key) => {
    const file = path.join(outputDir, `${key}.mp3`);
    return fs.existsSync(file) && fs.statSync(file).size > 0;
  });

  const registryContent = generateAssetsRegistry([{ locale, keys: successfulKeys }]);
  fs.writeFileSync(assetsRegistryFile, registryContent, 'utf-8');
  console.log(`  Registered ${successfulKeys.length} assets.\n`);

  if (failed > 0) {
    console.error(`Warning: ${failed} entries failed to generate. Re-run the script to retry.`);
    process.exit(1);
  }

  console.log('Done!');
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});
