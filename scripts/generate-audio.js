#!/usr/bin/env node

/**
 * Audio Generation Script
 *
 * Reads localization JSON files and generates speech audio using ElevenLabs API.
 * Also generates the audioAssets.ts registry file with static require() mappings.
 *
 * Pannable clips (op_*, num_*) are requested as PCM and converted to stereo
 * WAV files with panning baked in (_left.wav / _right.wav). Other clips are
 * saved as MP3.
 *
 * Usage:
 *   ELEVENLABS_API_KEY=sk_... node scripts/generate-audio.js [locale]
 *
 * Arguments:
 *   locale  - Language locale to generate (default: "en")
 *
 * Environment:
 *   ELEVENLABS_API_KEY - Required. Your ElevenLabs API key.
 */

const fs = require('fs');
const path = require('path');
const https = require('https');

const API_BASE = 'https://api.elevenlabs.io/v1';
const PCM_SAMPLE_RATE = 22050;

// --- Config ---

const locale = process.argv[2] || 'en';
const apiKey = process.env.ELEVENLABS_API_KEY;

if (!apiKey) {
  console.error('Error: ELEVENLABS_API_KEY environment variable is required.');
  console.error('Usage: ELEVENLABS_API_KEY=sk_... node scripts/generate-audio.js [locale]');
  process.exit(1);
}

const projectRoot = path.resolve(__dirname, '..');
const localizationFile = path.join(projectRoot, 'src', 'audio', 'localization', `${locale}.json`);
const outputDir = path.join(projectRoot, 'assets', 'audio', locale);
const assetsRegistryFile = path.join(projectRoot, 'src', 'audio', 'audioAssets.ts');

// --- Helpers ---

/** Whether this key needs left/right panned WAV files. */
function isPannable(key) {
  return key.startsWith('op_') || key.startsWith('num_');
}

function makeRequest(url, options, body) {
  return new Promise((resolve, reject) => {
    const req = https.request(url, options, (res) => {
      const chunks = [];
      res.on('data', (chunk) => chunks.push(chunk));
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(Buffer.concat(chunks));
        } else {
          const text = Buffer.concat(chunks).toString('utf-8');
          reject(new Error(`HTTP ${res.statusCode}: ${text}`));
        }
      });
    });
    req.on('error', reject);
    if (body) req.write(body);
    req.end();
  });
}

/**
 * Generate speech audio via ElevenLabs.
 * @param {string} outputFormat - 'mp3_44100_128' or 'pcm_22050'
 */
async function generateSpeech(text, voiceId, modelId, voiceSettings, outputFormat) {
  const url = `${API_BASE}/text-to-speech/${voiceId}?output_format=${outputFormat}`;
  const body = JSON.stringify({
    text,
    model_id: modelId,
    voice_settings: {
      stability: voiceSettings.stability,
      similarity_boost: voiceSettings.similarity_boost,
    },
  });

  const options = {
    method: 'POST',
    headers: {
      'xi-api-key': apiKey,
      'Content-Type': 'application/json',
      Accept: outputFormat.startsWith('pcm') ? 'audio/pcm' : 'audio/mpeg',
    },
  };

  return makeRequest(url, options, body);
}

/**
 * Create a stereo WAV buffer from mono PCM samples with panning.
 * @param {Buffer} pcmBuffer - Raw mono 16-bit signed LE PCM samples
 * @param {number} sampleRate
 * @param {'left'|'right'} pan - Which ear gets the full audio
 */
function createPannedWav(pcmBuffer, sampleRate, pan) {
  const numSamples = Math.floor(pcmBuffer.length / 2); // 16-bit = 2 bytes
  const numChannels = 2;
  const bitsPerSample = 16;
  const blockAlign = numChannels * (bitsPerSample / 8);
  const byteRate = sampleRate * blockAlign;
  const dataSize = numSamples * blockAlign;
  const fileSize = 44 + dataSize;

  const wav = Buffer.alloc(fileSize);

  // RIFF header
  wav.write('RIFF', 0);
  wav.writeUInt32LE(fileSize - 8, 4);
  wav.write('WAVE', 8);

  // fmt chunk
  wav.write('fmt ', 12);
  wav.writeUInt32LE(16, 16);
  wav.writeUInt16LE(1, 20); // PCM
  wav.writeUInt16LE(numChannels, 22);
  wav.writeUInt32LE(sampleRate, 24);
  wav.writeUInt32LE(byteRate, 28);
  wav.writeUInt16LE(blockAlign, 32);
  wav.writeUInt16LE(bitsPerSample, 34);

  // data chunk
  wav.write('data', 36);
  wav.writeUInt32LE(dataSize, 40);

  // Write stereo samples with panning
  for (let i = 0; i < numSamples; i++) {
    const sample = pcmBuffer.readInt16LE(i * 2);
    const quiet = Math.round(sample * 0.08); // near-silent bleed
    const offset = 44 + i * blockAlign;

    if (pan === 'left') {
      wav.writeInt16LE(sample, offset);       // left: full
      wav.writeInt16LE(quiet, offset + 2);    // right: near-silent
    } else {
      wav.writeInt16LE(quiet, offset);        // left: near-silent
      wav.writeInt16LE(sample, offset + 2);   // right: full
    }
  }

  return wav;
}

async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Build audioAssets.ts registry content.
 * Pannable keys get _left/_right WAV entries; others get MP3 entries.
 */
function generateAssetsRegistry(locales) {
  const lines = [
    '// AUTO-GENERATED by scripts/generate-audio.js',
    '// Do not edit manually. Run the audio generation workflow to update.',
    '',
    'export const AUDIO_ASSETS: Record<string, any> = {',
  ];

  for (const { locale, keys } of locales) {
    for (const key of keys) {
      if (isPannable(key)) {
        lines.push(`  '${key}_left': require('../../assets/audio/${locale}/${key}_left.wav'),`);
        lines.push(`  '${key}_right': require('../../assets/audio/${locale}/${key}_right.wav'),`);
      } else {
        lines.push(`  '${key}': require('../../assets/audio/${locale}/${key}.mp3'),`);
      }
    }
  }

  lines.push('};');
  lines.push('');

  return lines.join('\n');
}

// --- Main ---

async function main() {
  console.log(`\nAudio Generation Script`);
  console.log(`=======================`);
  console.log(`Locale: ${locale}`);
  console.log(`Localization file: ${localizationFile}`);
  console.log(`Output directory: ${outputDir}\n`);

  // Read localization file
  if (!fs.existsSync(localizationFile)) {
    console.error(`Error: Localization file not found: ${localizationFile}`);
    process.exit(1);
  }

  const localization = JSON.parse(fs.readFileSync(localizationFile, 'utf-8'));
  const { voice, entries } = localization;

  if (!voice || !entries) {
    console.error('Error: Localization file must have "voice" and "entries" fields.');
    process.exit(1);
  }

  const voiceId = voice.voiceId;
  const modelId = voice.modelId || 'eleven_flash_v2_5';
  const voiceSettings = voice.settings || { stability: 0.7, similarity_boost: 0.8 };

  // Ensure output directory exists
  fs.mkdirSync(outputDir, { recursive: true });

  const entryKeys = Object.keys(entries);
  const totalEntries = entryKeys.length;
  let generated = 0;
  let skipped = 0;
  let failed = 0;

  console.log(`Found ${totalEntries} entries to generate.\n`);

  for (const key of entryKeys) {
    const text = entries[key];
    const pannable = isPannable(key);

    if (pannable) {
      // Pannable clips: generate left/right stereo WAV files
      const leftFile = path.join(outputDir, `${key}_left.wav`);
      const rightFile = path.join(outputDir, `${key}_right.wav`);

      if (fs.existsSync(leftFile) && fs.statSync(leftFile).size > 0 &&
          fs.existsSync(rightFile) && fs.statSync(rightFile).size > 0) {
        console.log(`  [SKIP] ${key} (left/right WAV already exist)`);
        skipped++;
        continue;
      }

      console.log(`  [GEN]  ${key}: "${text}" (PCM → stereo WAV)`);

      try {
        const pcmBuffer = await generateSpeech(text, voiceId, modelId, voiceSettings, 'pcm_22050');
        fs.writeFileSync(leftFile, createPannedWav(pcmBuffer, PCM_SAMPLE_RATE, 'left'));
        fs.writeFileSync(rightFile, createPannedWav(pcmBuffer, PCM_SAMPLE_RATE, 'right'));
        generated++;
        await sleep(500);
      } catch (err) {
        console.error(`  [FAIL] ${key}: ${err.message}`);
        failed++;
      }
    } else {
      // Non-pannable clips: generate MP3
      const outputFile = path.join(outputDir, `${key}.mp3`);

      if (fs.existsSync(outputFile) && fs.statSync(outputFile).size > 0) {
        console.log(`  [SKIP] ${key} (already exists)`);
        skipped++;
        continue;
      }

      console.log(`  [GEN]  ${key}: "${text}" (MP3)`);

      try {
        const audioBuffer = await generateSpeech(text, voiceId, modelId, voiceSettings, 'mp3_44100_128');
        fs.writeFileSync(outputFile, audioBuffer);
        generated++;
        await sleep(500);
      } catch (err) {
        console.error(`  [FAIL] ${key}: ${err.message}`);
        failed++;
      }
    }
  }

  console.log(`\nGeneration complete:`);
  console.log(`  Generated: ${generated}`);
  console.log(`  Skipped:   ${skipped}`);
  console.log(`  Failed:    ${failed}`);
  console.log(`  Total:     ${totalEntries}\n`);

  // Generate audioAssets.ts registry
  console.log(`Generating asset registry: ${assetsRegistryFile}`);

  const successfulKeys = entryKeys.filter((key) => {
    if (isPannable(key)) {
      const left = path.join(outputDir, `${key}_left.wav`);
      const right = path.join(outputDir, `${key}_right.wav`);
      return fs.existsSync(left) && fs.statSync(left).size > 0 &&
             fs.existsSync(right) && fs.statSync(right).size > 0;
    }
    const file = path.join(outputDir, `${key}.mp3`);
    return fs.existsSync(file) && fs.statSync(file).size > 0;
  });

  const registryContent = generateAssetsRegistry([{ locale, keys: successfulKeys }]);
  fs.writeFileSync(assetsRegistryFile, registryContent, 'utf-8');

  const pannableCount = successfulKeys.filter(isPannable).length;
  console.log(`  Registered ${successfulKeys.length} entries (${pannableCount} pannable × 2 WAVs).\n`);

  if (failed > 0) {
    console.error(`Warning: ${failed} entries failed to generate. Re-run the script to retry.`);
    process.exit(1);
  }

  console.log('Done!');
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});
